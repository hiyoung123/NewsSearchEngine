// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base_service.proto

#ifndef PROTOBUF_base_5fservice_2eproto__INCLUDED
#define PROTOBUF_base_5fservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace NLP {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_base_5fservice_2eproto();
void protobuf_AssignDesc_base_5fservice_2eproto();
void protobuf_ShutdownFile_base_5fservice_2eproto();

class SegmentResult;
class SegmentRequest;
class SegmentResponse;
class IndexItem;
class WordItem;
class RecallRequest;
class RecallResponse;
class SortReqItem;
class SortRequest;
class SortResItem;
class SortResponse;

// ===================================================================

class SegmentResult : public ::google::protobuf::Message {
 public:
  SegmentResult();
  virtual ~SegmentResult();

  SegmentResult(const SegmentResult& from);

  inline SegmentResult& operator=(const SegmentResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentResult& default_instance();

  void Swap(SegmentResult* other);

  // implements Message ----------------------------------------------

  SegmentResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentResult& from);
  void MergeFrom(const SegmentResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required int32 TF = 2;
  inline bool has_tf() const;
  inline void clear_tf();
  static const int kTFFieldNumber = 2;
  inline ::google::protobuf::int32 tf() const;
  inline void set_tf(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NLP.SegmentResult)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_tf();
  inline void clear_has_tf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* token_;
  ::google::protobuf::int32 tf_;
  friend void  protobuf_AddDesc_base_5fservice_2eproto();
  friend void protobuf_AssignDesc_base_5fservice_2eproto();
  friend void protobuf_ShutdownFile_base_5fservice_2eproto();

  void InitAsDefaultInstance();
  static SegmentResult* default_instance_;
};
// -------------------------------------------------------------------

class SegmentRequest : public ::google::protobuf::Message {
 public:
  SegmentRequest();
  virtual ~SegmentRequest();

  SegmentRequest(const SegmentRequest& from);

  inline SegmentRequest& operator=(const SegmentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentRequest& default_instance();

  void Swap(SegmentRequest* other);

  // implements Message ----------------------------------------------

  SegmentRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentRequest& from);
  void MergeFrom(const SegmentRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sentence = 1;
  inline bool has_sentence() const;
  inline void clear_sentence();
  static const int kSentenceFieldNumber = 1;
  inline const ::std::string& sentence() const;
  inline void set_sentence(const ::std::string& value);
  inline void set_sentence(const char* value);
  inline void set_sentence(const char* value, size_t size);
  inline ::std::string* mutable_sentence();
  inline ::std::string* release_sentence();
  inline void set_allocated_sentence(::std::string* sentence);

  // @@protoc_insertion_point(class_scope:NLP.SegmentRequest)
 private:
  inline void set_has_sentence();
  inline void clear_has_sentence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sentence_;
  friend void  protobuf_AddDesc_base_5fservice_2eproto();
  friend void protobuf_AssignDesc_base_5fservice_2eproto();
  friend void protobuf_ShutdownFile_base_5fservice_2eproto();

  void InitAsDefaultInstance();
  static SegmentRequest* default_instance_;
};
// -------------------------------------------------------------------

class SegmentResponse : public ::google::protobuf::Message {
 public:
  SegmentResponse();
  virtual ~SegmentResponse();

  SegmentResponse(const SegmentResponse& from);

  inline SegmentResponse& operator=(const SegmentResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentResponse& default_instance();

  void Swap(SegmentResponse* other);

  // implements Message ----------------------------------------------

  SegmentResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SegmentResponse& from);
  void MergeFrom(const SegmentResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NLP.SegmentResult result = 1;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::NLP::SegmentResult& result(int index) const;
  inline ::NLP::SegmentResult* mutable_result(int index);
  inline ::NLP::SegmentResult* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:NLP.SegmentResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult > result_;
  friend void  protobuf_AddDesc_base_5fservice_2eproto();
  friend void protobuf_AssignDesc_base_5fservice_2eproto();
  friend void protobuf_ShutdownFile_base_5fservice_2eproto();

  void InitAsDefaultInstance();
  static SegmentResponse* default_instance_;
};
// -------------------------------------------------------------------

class IndexItem : public ::google::protobuf::Message {
 public:
  IndexItem();
  virtual ~IndexItem();

  IndexItem(const IndexItem& from);

  inline IndexItem& operator=(const IndexItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexItem& default_instance();

  void Swap(IndexItem* other);

  // implements Message ----------------------------------------------

  IndexItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IndexItem& from);
  void MergeFrom(const IndexItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 DocId = 1;
  inline bool has_docid() const;
  inline void clear_docid();
  static const int kDocIdFieldNumber = 1;
  inline ::google::protobuf::int32 docid() const;
  inline void set_docid(::google::protobuf::int32 value);

  // required int32 TF = 2;
  inline bool has_tf() const;
  inline void clear_tf();
  static const int kTFFieldNumber = 2;
  inline ::google::protobuf::int32 tf() const;
  inline void set_tf(::google::protobuf::int32 value);

  // required int32 dl = 3;
  inline bool has_dl() const;
  inline void clear_dl();
  static const int kDlFieldNumber = 3;
  inline ::google::protobuf::int32 dl() const;
  inline void set_dl(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NLP.IndexItem)
 private:
  inline void set_has_docid();
  inline void clear_has_docid();
  inline void set_has_tf();
  inline void clear_has_tf();
  inline void set_has_dl();
  inline void clear_has_dl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 docid_;
  ::google::protobuf::int32 tf_;
  ::google::protobuf::int32 dl_;
  friend void  protobuf_AddDesc_base_5fservice_2eproto();
  friend void protobuf_AssignDesc_base_5fservice_2eproto();
  friend void protobuf_ShutdownFile_base_5fservice_2eproto();

  void InitAsDefaultInstance();
  static IndexItem* default_instance_;
};
// -------------------------------------------------------------------

class WordItem : public ::google::protobuf::Message {
 public:
  WordItem();
  virtual ~WordItem();

  WordItem(const WordItem& from);

  inline WordItem& operator=(const WordItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WordItem& default_instance();

  void Swap(WordItem* other);

  // implements Message ----------------------------------------------

  WordItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WordItem& from);
  void MergeFrom(const WordItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string word = 1;
  inline bool has_word() const;
  inline void clear_word();
  static const int kWordFieldNumber = 1;
  inline const ::std::string& word() const;
  inline void set_word(const ::std::string& value);
  inline void set_word(const char* value);
  inline void set_word(const char* value, size_t size);
  inline ::std::string* mutable_word();
  inline ::std::string* release_word();
  inline void set_allocated_word(::std::string* word);

  // required int32 DF = 2;
  inline bool has_df() const;
  inline void clear_df();
  static const int kDFFieldNumber = 2;
  inline ::google::protobuf::int32 df() const;
  inline void set_df(::google::protobuf::int32 value);

  // repeated .NLP.IndexItem index_item = 3;
  inline int index_item_size() const;
  inline void clear_index_item();
  static const int kIndexItemFieldNumber = 3;
  inline const ::NLP::IndexItem& index_item(int index) const;
  inline ::NLP::IndexItem* mutable_index_item(int index);
  inline ::NLP::IndexItem* add_index_item();
  inline const ::google::protobuf::RepeatedPtrField< ::NLP::IndexItem >&
      index_item() const;
  inline ::google::protobuf::RepeatedPtrField< ::NLP::IndexItem >*
      mutable_index_item();

  // @@protoc_insertion_point(class_scope:NLP.WordItem)
 private:
  inline void set_has_word();
  inline void clear_has_word();
  inline void set_has_df();
  inline void clear_has_df();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* word_;
  ::google::protobuf::RepeatedPtrField< ::NLP::IndexItem > index_item_;
  ::google::protobuf::int32 df_;
  friend void  protobuf_AddDesc_base_5fservice_2eproto();
  friend void protobuf_AssignDesc_base_5fservice_2eproto();
  friend void protobuf_ShutdownFile_base_5fservice_2eproto();

  void InitAsDefaultInstance();
  static WordItem* default_instance_;
};
// -------------------------------------------------------------------

class RecallRequest : public ::google::protobuf::Message {
 public:
  RecallRequest();
  virtual ~RecallRequest();

  RecallRequest(const RecallRequest& from);

  inline RecallRequest& operator=(const RecallRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecallRequest& default_instance();

  void Swap(RecallRequest* other);

  // implements Message ----------------------------------------------

  RecallRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecallRequest& from);
  void MergeFrom(const RecallRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tokens = 1;
  inline int tokens_size() const;
  inline void clear_tokens();
  static const int kTokensFieldNumber = 1;
  inline const ::std::string& tokens(int index) const;
  inline ::std::string* mutable_tokens(int index);
  inline void set_tokens(int index, const ::std::string& value);
  inline void set_tokens(int index, const char* value);
  inline void set_tokens(int index, const char* value, size_t size);
  inline ::std::string* add_tokens();
  inline void add_tokens(const ::std::string& value);
  inline void add_tokens(const char* value);
  inline void add_tokens(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tokens();

  // @@protoc_insertion_point(class_scope:NLP.RecallRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tokens_;
  friend void  protobuf_AddDesc_base_5fservice_2eproto();
  friend void protobuf_AssignDesc_base_5fservice_2eproto();
  friend void protobuf_ShutdownFile_base_5fservice_2eproto();

  void InitAsDefaultInstance();
  static RecallRequest* default_instance_;
};
// -------------------------------------------------------------------

class RecallResponse : public ::google::protobuf::Message {
 public:
  RecallResponse();
  virtual ~RecallResponse();

  RecallResponse(const RecallResponse& from);

  inline RecallResponse& operator=(const RecallResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecallResponse& default_instance();

  void Swap(RecallResponse* other);

  // implements Message ----------------------------------------------

  RecallResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecallResponse& from);
  void MergeFrom(const RecallResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NLP.WordItem result = 1;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::NLP::WordItem& result(int index) const;
  inline ::NLP::WordItem* mutable_result(int index);
  inline ::NLP::WordItem* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::NLP::WordItem >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::NLP::WordItem >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:NLP.RecallResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NLP::WordItem > result_;
  friend void  protobuf_AddDesc_base_5fservice_2eproto();
  friend void protobuf_AssignDesc_base_5fservice_2eproto();
  friend void protobuf_ShutdownFile_base_5fservice_2eproto();

  void InitAsDefaultInstance();
  static RecallResponse* default_instance_;
};
// -------------------------------------------------------------------

class SortReqItem : public ::google::protobuf::Message {
 public:
  SortReqItem();
  virtual ~SortReqItem();

  SortReqItem(const SortReqItem& from);

  inline SortReqItem& operator=(const SortReqItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SortReqItem& default_instance();

  void Swap(SortReqItem* other);

  // implements Message ----------------------------------------------

  SortReqItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SortReqItem& from);
  void MergeFrom(const SortReqItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string word = 1;
  inline bool has_word() const;
  inline void clear_word();
  static const int kWordFieldNumber = 1;
  inline const ::std::string& word() const;
  inline void set_word(const ::std::string& value);
  inline void set_word(const char* value);
  inline void set_word(const char* value, size_t size);
  inline ::std::string* mutable_word();
  inline ::std::string* release_word();
  inline void set_allocated_word(::std::string* word);

  // required int32 DF = 2;
  inline bool has_df() const;
  inline void clear_df();
  static const int kDFFieldNumber = 2;
  inline ::google::protobuf::int32 df() const;
  inline void set_df(::google::protobuf::int32 value);

  // required int32 qtf = 3;
  inline bool has_qtf() const;
  inline void clear_qtf();
  static const int kQtfFieldNumber = 3;
  inline ::google::protobuf::int32 qtf() const;
  inline void set_qtf(::google::protobuf::int32 value);

  // repeated .NLP.IndexItem index_item = 4;
  inline int index_item_size() const;
  inline void clear_index_item();
  static const int kIndexItemFieldNumber = 4;
  inline const ::NLP::IndexItem& index_item(int index) const;
  inline ::NLP::IndexItem* mutable_index_item(int index);
  inline ::NLP::IndexItem* add_index_item();
  inline const ::google::protobuf::RepeatedPtrField< ::NLP::IndexItem >&
      index_item() const;
  inline ::google::protobuf::RepeatedPtrField< ::NLP::IndexItem >*
      mutable_index_item();

  // @@protoc_insertion_point(class_scope:NLP.SortReqItem)
 private:
  inline void set_has_word();
  inline void clear_has_word();
  inline void set_has_df();
  inline void clear_has_df();
  inline void set_has_qtf();
  inline void clear_has_qtf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* word_;
  ::google::protobuf::int32 df_;
  ::google::protobuf::int32 qtf_;
  ::google::protobuf::RepeatedPtrField< ::NLP::IndexItem > index_item_;
  friend void  protobuf_AddDesc_base_5fservice_2eproto();
  friend void protobuf_AssignDesc_base_5fservice_2eproto();
  friend void protobuf_ShutdownFile_base_5fservice_2eproto();

  void InitAsDefaultInstance();
  static SortReqItem* default_instance_;
};
// -------------------------------------------------------------------

class SortRequest : public ::google::protobuf::Message {
 public:
  SortRequest();
  virtual ~SortRequest();

  SortRequest(const SortRequest& from);

  inline SortRequest& operator=(const SortRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SortRequest& default_instance();

  void Swap(SortRequest* other);

  // implements Message ----------------------------------------------

  SortRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SortRequest& from);
  void MergeFrom(const SortRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NLP.SortReqItem item = 1;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::NLP::SortReqItem& item(int index) const;
  inline ::NLP::SortReqItem* mutable_item(int index);
  inline ::NLP::SortReqItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::NLP::SortReqItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::NLP::SortReqItem >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:NLP.SortRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NLP::SortReqItem > item_;
  friend void  protobuf_AddDesc_base_5fservice_2eproto();
  friend void protobuf_AssignDesc_base_5fservice_2eproto();
  friend void protobuf_ShutdownFile_base_5fservice_2eproto();

  void InitAsDefaultInstance();
  static SortRequest* default_instance_;
};
// -------------------------------------------------------------------

class SortResItem : public ::google::protobuf::Message {
 public:
  SortResItem();
  virtual ~SortResItem();

  SortResItem(const SortResItem& from);

  inline SortResItem& operator=(const SortResItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SortResItem& default_instance();

  void Swap(SortResItem* other);

  // implements Message ----------------------------------------------

  SortResItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SortResItem& from);
  void MergeFrom(const SortResItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 DocId = 1;
  inline bool has_docid() const;
  inline void clear_docid();
  static const int kDocIdFieldNumber = 1;
  inline ::google::protobuf::int32 docid() const;
  inline void set_docid(::google::protobuf::int32 value);

  // required float score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:NLP.SortResItem)
 private:
  inline void set_has_docid();
  inline void clear_has_docid();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 docid_;
  float score_;
  friend void  protobuf_AddDesc_base_5fservice_2eproto();
  friend void protobuf_AssignDesc_base_5fservice_2eproto();
  friend void protobuf_ShutdownFile_base_5fservice_2eproto();

  void InitAsDefaultInstance();
  static SortResItem* default_instance_;
};
// -------------------------------------------------------------------

class SortResponse : public ::google::protobuf::Message {
 public:
  SortResponse();
  virtual ~SortResponse();

  SortResponse(const SortResponse& from);

  inline SortResponse& operator=(const SortResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SortResponse& default_instance();

  void Swap(SortResponse* other);

  // implements Message ----------------------------------------------

  SortResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SortResponse& from);
  void MergeFrom(const SortResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NLP.SortResItem result = 1;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::NLP::SortResItem& result(int index) const;
  inline ::NLP::SortResItem* mutable_result(int index);
  inline ::NLP::SortResItem* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::NLP::SortResItem >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::NLP::SortResItem >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:NLP.SortResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NLP::SortResItem > result_;
  friend void  protobuf_AddDesc_base_5fservice_2eproto();
  friend void protobuf_AssignDesc_base_5fservice_2eproto();
  friend void protobuf_ShutdownFile_base_5fservice_2eproto();

  void InitAsDefaultInstance();
  static SortResponse* default_instance_;
};
// ===================================================================

class SegmentService_Stub;

class SegmentService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline SegmentService() {};
 public:
  virtual ~SegmentService();

  typedef SegmentService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void cut(::google::protobuf::RpcController* controller,
                       const ::NLP::SegmentRequest* request,
                       ::NLP::SegmentResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SegmentService);
};

class SegmentService_Stub : public SegmentService {
 public:
  SegmentService_Stub(::google::protobuf::RpcChannel* channel);
  SegmentService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~SegmentService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements SegmentService ------------------------------------------

  void cut(::google::protobuf::RpcController* controller,
                       const ::NLP::SegmentRequest* request,
                       ::NLP::SegmentResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SegmentService_Stub);
};


// -------------------------------------------------------------------

class RecallService_Stub;

class RecallService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline RecallService() {};
 public:
  virtual ~RecallService();

  typedef RecallService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void recall(::google::protobuf::RpcController* controller,
                       const ::NLP::RecallRequest* request,
                       ::NLP::RecallResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RecallService);
};

class RecallService_Stub : public RecallService {
 public:
  RecallService_Stub(::google::protobuf::RpcChannel* channel);
  RecallService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~RecallService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements RecallService ------------------------------------------

  void recall(::google::protobuf::RpcController* controller,
                       const ::NLP::RecallRequest* request,
                       ::NLP::RecallResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RecallService_Stub);
};


// -------------------------------------------------------------------

class SortService_Stub;

class SortService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline SortService() {};
 public:
  virtual ~SortService();

  typedef SortService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void sort(::google::protobuf::RpcController* controller,
                       const ::NLP::SortRequest* request,
                       ::NLP::SortResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SortService);
};

class SortService_Stub : public SortService {
 public:
  SortService_Stub(::google::protobuf::RpcChannel* channel);
  SortService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~SortService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements SortService ------------------------------------------

  void sort(::google::protobuf::RpcController* controller,
                       const ::NLP::SortRequest* request,
                       ::NLP::SortResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SortService_Stub);
};


// ===================================================================


// ===================================================================

// SegmentResult

// required string token = 1;
inline bool SegmentResult::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SegmentResult::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SegmentResult::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SegmentResult::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& SegmentResult::token() const {
  // @@protoc_insertion_point(field_get:NLP.SegmentResult.token)
  return *token_;
}
inline void SegmentResult::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:NLP.SegmentResult.token)
}
inline void SegmentResult::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:NLP.SegmentResult.token)
}
inline void SegmentResult::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NLP.SegmentResult.token)
}
inline ::std::string* SegmentResult::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NLP.SegmentResult.token)
  return token_;
}
inline ::std::string* SegmentResult::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SegmentResult::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NLP.SegmentResult.token)
}

// required int32 TF = 2;
inline bool SegmentResult::has_tf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SegmentResult::set_has_tf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SegmentResult::clear_has_tf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SegmentResult::clear_tf() {
  tf_ = 0;
  clear_has_tf();
}
inline ::google::protobuf::int32 SegmentResult::tf() const {
  // @@protoc_insertion_point(field_get:NLP.SegmentResult.TF)
  return tf_;
}
inline void SegmentResult::set_tf(::google::protobuf::int32 value) {
  set_has_tf();
  tf_ = value;
  // @@protoc_insertion_point(field_set:NLP.SegmentResult.TF)
}

// -------------------------------------------------------------------

// SegmentRequest

// required string sentence = 1;
inline bool SegmentRequest::has_sentence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SegmentRequest::set_has_sentence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SegmentRequest::clear_has_sentence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SegmentRequest::clear_sentence() {
  if (sentence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sentence_->clear();
  }
  clear_has_sentence();
}
inline const ::std::string& SegmentRequest::sentence() const {
  // @@protoc_insertion_point(field_get:NLP.SegmentRequest.sentence)
  return *sentence_;
}
inline void SegmentRequest::set_sentence(const ::std::string& value) {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sentence_ = new ::std::string;
  }
  sentence_->assign(value);
  // @@protoc_insertion_point(field_set:NLP.SegmentRequest.sentence)
}
inline void SegmentRequest::set_sentence(const char* value) {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sentence_ = new ::std::string;
  }
  sentence_->assign(value);
  // @@protoc_insertion_point(field_set_char:NLP.SegmentRequest.sentence)
}
inline void SegmentRequest::set_sentence(const char* value, size_t size) {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sentence_ = new ::std::string;
  }
  sentence_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NLP.SegmentRequest.sentence)
}
inline ::std::string* SegmentRequest::mutable_sentence() {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sentence_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NLP.SegmentRequest.sentence)
  return sentence_;
}
inline ::std::string* SegmentRequest::release_sentence() {
  clear_has_sentence();
  if (sentence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sentence_;
    sentence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SegmentRequest::set_allocated_sentence(::std::string* sentence) {
  if (sentence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sentence_;
  }
  if (sentence) {
    set_has_sentence();
    sentence_ = sentence;
  } else {
    clear_has_sentence();
    sentence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NLP.SegmentRequest.sentence)
}

// -------------------------------------------------------------------

// SegmentResponse

// repeated .NLP.SegmentResult result = 1;
inline int SegmentResponse::result_size() const {
  return result_.size();
}
inline void SegmentResponse::clear_result() {
  result_.Clear();
}
inline const ::NLP::SegmentResult& SegmentResponse::result(int index) const {
  // @@protoc_insertion_point(field_get:NLP.SegmentResponse.result)
  return result_.Get(index);
}
inline ::NLP::SegmentResult* SegmentResponse::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:NLP.SegmentResponse.result)
  return result_.Mutable(index);
}
inline ::NLP::SegmentResult* SegmentResponse::add_result() {
  // @@protoc_insertion_point(field_add:NLP.SegmentResponse.result)
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >&
SegmentResponse::result() const {
  // @@protoc_insertion_point(field_list:NLP.SegmentResponse.result)
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::NLP::SegmentResult >*
SegmentResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:NLP.SegmentResponse.result)
  return &result_;
}

// -------------------------------------------------------------------

// IndexItem

// required int32 DocId = 1;
inline bool IndexItem::has_docid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IndexItem::set_has_docid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IndexItem::clear_has_docid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IndexItem::clear_docid() {
  docid_ = 0;
  clear_has_docid();
}
inline ::google::protobuf::int32 IndexItem::docid() const {
  // @@protoc_insertion_point(field_get:NLP.IndexItem.DocId)
  return docid_;
}
inline void IndexItem::set_docid(::google::protobuf::int32 value) {
  set_has_docid();
  docid_ = value;
  // @@protoc_insertion_point(field_set:NLP.IndexItem.DocId)
}

// required int32 TF = 2;
inline bool IndexItem::has_tf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IndexItem::set_has_tf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IndexItem::clear_has_tf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IndexItem::clear_tf() {
  tf_ = 0;
  clear_has_tf();
}
inline ::google::protobuf::int32 IndexItem::tf() const {
  // @@protoc_insertion_point(field_get:NLP.IndexItem.TF)
  return tf_;
}
inline void IndexItem::set_tf(::google::protobuf::int32 value) {
  set_has_tf();
  tf_ = value;
  // @@protoc_insertion_point(field_set:NLP.IndexItem.TF)
}

// required int32 dl = 3;
inline bool IndexItem::has_dl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IndexItem::set_has_dl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IndexItem::clear_has_dl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IndexItem::clear_dl() {
  dl_ = 0;
  clear_has_dl();
}
inline ::google::protobuf::int32 IndexItem::dl() const {
  // @@protoc_insertion_point(field_get:NLP.IndexItem.dl)
  return dl_;
}
inline void IndexItem::set_dl(::google::protobuf::int32 value) {
  set_has_dl();
  dl_ = value;
  // @@protoc_insertion_point(field_set:NLP.IndexItem.dl)
}

// -------------------------------------------------------------------

// WordItem

// required string word = 1;
inline bool WordItem::has_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WordItem::set_has_word() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WordItem::clear_has_word() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WordItem::clear_word() {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_->clear();
  }
  clear_has_word();
}
inline const ::std::string& WordItem::word() const {
  // @@protoc_insertion_point(field_get:NLP.WordItem.word)
  return *word_;
}
inline void WordItem::set_word(const ::std::string& value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(value);
  // @@protoc_insertion_point(field_set:NLP.WordItem.word)
}
inline void WordItem::set_word(const char* value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(value);
  // @@protoc_insertion_point(field_set_char:NLP.WordItem.word)
}
inline void WordItem::set_word(const char* value, size_t size) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NLP.WordItem.word)
}
inline ::std::string* WordItem::mutable_word() {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NLP.WordItem.word)
  return word_;
}
inline ::std::string* WordItem::release_word() {
  clear_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = word_;
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WordItem::set_allocated_word(::std::string* word) {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete word_;
  }
  if (word) {
    set_has_word();
    word_ = word;
  } else {
    clear_has_word();
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NLP.WordItem.word)
}

// required int32 DF = 2;
inline bool WordItem::has_df() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WordItem::set_has_df() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WordItem::clear_has_df() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WordItem::clear_df() {
  df_ = 0;
  clear_has_df();
}
inline ::google::protobuf::int32 WordItem::df() const {
  // @@protoc_insertion_point(field_get:NLP.WordItem.DF)
  return df_;
}
inline void WordItem::set_df(::google::protobuf::int32 value) {
  set_has_df();
  df_ = value;
  // @@protoc_insertion_point(field_set:NLP.WordItem.DF)
}

// repeated .NLP.IndexItem index_item = 3;
inline int WordItem::index_item_size() const {
  return index_item_.size();
}
inline void WordItem::clear_index_item() {
  index_item_.Clear();
}
inline const ::NLP::IndexItem& WordItem::index_item(int index) const {
  // @@protoc_insertion_point(field_get:NLP.WordItem.index_item)
  return index_item_.Get(index);
}
inline ::NLP::IndexItem* WordItem::mutable_index_item(int index) {
  // @@protoc_insertion_point(field_mutable:NLP.WordItem.index_item)
  return index_item_.Mutable(index);
}
inline ::NLP::IndexItem* WordItem::add_index_item() {
  // @@protoc_insertion_point(field_add:NLP.WordItem.index_item)
  return index_item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NLP::IndexItem >&
WordItem::index_item() const {
  // @@protoc_insertion_point(field_list:NLP.WordItem.index_item)
  return index_item_;
}
inline ::google::protobuf::RepeatedPtrField< ::NLP::IndexItem >*
WordItem::mutable_index_item() {
  // @@protoc_insertion_point(field_mutable_list:NLP.WordItem.index_item)
  return &index_item_;
}

// -------------------------------------------------------------------

// RecallRequest

// repeated string tokens = 1;
inline int RecallRequest::tokens_size() const {
  return tokens_.size();
}
inline void RecallRequest::clear_tokens() {
  tokens_.Clear();
}
inline const ::std::string& RecallRequest::tokens(int index) const {
  // @@protoc_insertion_point(field_get:NLP.RecallRequest.tokens)
  return tokens_.Get(index);
}
inline ::std::string* RecallRequest::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:NLP.RecallRequest.tokens)
  return tokens_.Mutable(index);
}
inline void RecallRequest::set_tokens(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NLP.RecallRequest.tokens)
  tokens_.Mutable(index)->assign(value);
}
inline void RecallRequest::set_tokens(int index, const char* value) {
  tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NLP.RecallRequest.tokens)
}
inline void RecallRequest::set_tokens(int index, const char* value, size_t size) {
  tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NLP.RecallRequest.tokens)
}
inline ::std::string* RecallRequest::add_tokens() {
  return tokens_.Add();
}
inline void RecallRequest::add_tokens(const ::std::string& value) {
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NLP.RecallRequest.tokens)
}
inline void RecallRequest::add_tokens(const char* value) {
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NLP.RecallRequest.tokens)
}
inline void RecallRequest::add_tokens(const char* value, size_t size) {
  tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NLP.RecallRequest.tokens)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RecallRequest::tokens() const {
  // @@protoc_insertion_point(field_list:NLP.RecallRequest.tokens)
  return tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RecallRequest::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:NLP.RecallRequest.tokens)
  return &tokens_;
}

// -------------------------------------------------------------------

// RecallResponse

// repeated .NLP.WordItem result = 1;
inline int RecallResponse::result_size() const {
  return result_.size();
}
inline void RecallResponse::clear_result() {
  result_.Clear();
}
inline const ::NLP::WordItem& RecallResponse::result(int index) const {
  // @@protoc_insertion_point(field_get:NLP.RecallResponse.result)
  return result_.Get(index);
}
inline ::NLP::WordItem* RecallResponse::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:NLP.RecallResponse.result)
  return result_.Mutable(index);
}
inline ::NLP::WordItem* RecallResponse::add_result() {
  // @@protoc_insertion_point(field_add:NLP.RecallResponse.result)
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NLP::WordItem >&
RecallResponse::result() const {
  // @@protoc_insertion_point(field_list:NLP.RecallResponse.result)
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::NLP::WordItem >*
RecallResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:NLP.RecallResponse.result)
  return &result_;
}

// -------------------------------------------------------------------

// SortReqItem

// required string word = 1;
inline bool SortReqItem::has_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SortReqItem::set_has_word() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SortReqItem::clear_has_word() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SortReqItem::clear_word() {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_->clear();
  }
  clear_has_word();
}
inline const ::std::string& SortReqItem::word() const {
  // @@protoc_insertion_point(field_get:NLP.SortReqItem.word)
  return *word_;
}
inline void SortReqItem::set_word(const ::std::string& value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(value);
  // @@protoc_insertion_point(field_set:NLP.SortReqItem.word)
}
inline void SortReqItem::set_word(const char* value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(value);
  // @@protoc_insertion_point(field_set_char:NLP.SortReqItem.word)
}
inline void SortReqItem::set_word(const char* value, size_t size) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NLP.SortReqItem.word)
}
inline ::std::string* SortReqItem::mutable_word() {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NLP.SortReqItem.word)
  return word_;
}
inline ::std::string* SortReqItem::release_word() {
  clear_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = word_;
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SortReqItem::set_allocated_word(::std::string* word) {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete word_;
  }
  if (word) {
    set_has_word();
    word_ = word;
  } else {
    clear_has_word();
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NLP.SortReqItem.word)
}

// required int32 DF = 2;
inline bool SortReqItem::has_df() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SortReqItem::set_has_df() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SortReqItem::clear_has_df() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SortReqItem::clear_df() {
  df_ = 0;
  clear_has_df();
}
inline ::google::protobuf::int32 SortReqItem::df() const {
  // @@protoc_insertion_point(field_get:NLP.SortReqItem.DF)
  return df_;
}
inline void SortReqItem::set_df(::google::protobuf::int32 value) {
  set_has_df();
  df_ = value;
  // @@protoc_insertion_point(field_set:NLP.SortReqItem.DF)
}

// required int32 qtf = 3;
inline bool SortReqItem::has_qtf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SortReqItem::set_has_qtf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SortReqItem::clear_has_qtf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SortReqItem::clear_qtf() {
  qtf_ = 0;
  clear_has_qtf();
}
inline ::google::protobuf::int32 SortReqItem::qtf() const {
  // @@protoc_insertion_point(field_get:NLP.SortReqItem.qtf)
  return qtf_;
}
inline void SortReqItem::set_qtf(::google::protobuf::int32 value) {
  set_has_qtf();
  qtf_ = value;
  // @@protoc_insertion_point(field_set:NLP.SortReqItem.qtf)
}

// repeated .NLP.IndexItem index_item = 4;
inline int SortReqItem::index_item_size() const {
  return index_item_.size();
}
inline void SortReqItem::clear_index_item() {
  index_item_.Clear();
}
inline const ::NLP::IndexItem& SortReqItem::index_item(int index) const {
  // @@protoc_insertion_point(field_get:NLP.SortReqItem.index_item)
  return index_item_.Get(index);
}
inline ::NLP::IndexItem* SortReqItem::mutable_index_item(int index) {
  // @@protoc_insertion_point(field_mutable:NLP.SortReqItem.index_item)
  return index_item_.Mutable(index);
}
inline ::NLP::IndexItem* SortReqItem::add_index_item() {
  // @@protoc_insertion_point(field_add:NLP.SortReqItem.index_item)
  return index_item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NLP::IndexItem >&
SortReqItem::index_item() const {
  // @@protoc_insertion_point(field_list:NLP.SortReqItem.index_item)
  return index_item_;
}
inline ::google::protobuf::RepeatedPtrField< ::NLP::IndexItem >*
SortReqItem::mutable_index_item() {
  // @@protoc_insertion_point(field_mutable_list:NLP.SortReqItem.index_item)
  return &index_item_;
}

// -------------------------------------------------------------------

// SortRequest

// repeated .NLP.SortReqItem item = 1;
inline int SortRequest::item_size() const {
  return item_.size();
}
inline void SortRequest::clear_item() {
  item_.Clear();
}
inline const ::NLP::SortReqItem& SortRequest::item(int index) const {
  // @@protoc_insertion_point(field_get:NLP.SortRequest.item)
  return item_.Get(index);
}
inline ::NLP::SortReqItem* SortRequest::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:NLP.SortRequest.item)
  return item_.Mutable(index);
}
inline ::NLP::SortReqItem* SortRequest::add_item() {
  // @@protoc_insertion_point(field_add:NLP.SortRequest.item)
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NLP::SortReqItem >&
SortRequest::item() const {
  // @@protoc_insertion_point(field_list:NLP.SortRequest.item)
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::NLP::SortReqItem >*
SortRequest::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:NLP.SortRequest.item)
  return &item_;
}

// -------------------------------------------------------------------

// SortResItem

// required int32 DocId = 1;
inline bool SortResItem::has_docid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SortResItem::set_has_docid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SortResItem::clear_has_docid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SortResItem::clear_docid() {
  docid_ = 0;
  clear_has_docid();
}
inline ::google::protobuf::int32 SortResItem::docid() const {
  // @@protoc_insertion_point(field_get:NLP.SortResItem.DocId)
  return docid_;
}
inline void SortResItem::set_docid(::google::protobuf::int32 value) {
  set_has_docid();
  docid_ = value;
  // @@protoc_insertion_point(field_set:NLP.SortResItem.DocId)
}

// required float score = 2;
inline bool SortResItem::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SortResItem::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SortResItem::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SortResItem::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float SortResItem::score() const {
  // @@protoc_insertion_point(field_get:NLP.SortResItem.score)
  return score_;
}
inline void SortResItem::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:NLP.SortResItem.score)
}

// -------------------------------------------------------------------

// SortResponse

// repeated .NLP.SortResItem result = 1;
inline int SortResponse::result_size() const {
  return result_.size();
}
inline void SortResponse::clear_result() {
  result_.Clear();
}
inline const ::NLP::SortResItem& SortResponse::result(int index) const {
  // @@protoc_insertion_point(field_get:NLP.SortResponse.result)
  return result_.Get(index);
}
inline ::NLP::SortResItem* SortResponse::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:NLP.SortResponse.result)
  return result_.Mutable(index);
}
inline ::NLP::SortResItem* SortResponse::add_result() {
  // @@protoc_insertion_point(field_add:NLP.SortResponse.result)
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NLP::SortResItem >&
SortResponse::result() const {
  // @@protoc_insertion_point(field_list:NLP.SortResponse.result)
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::NLP::SortResItem >*
SortResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:NLP.SortResponse.result)
  return &result_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace NLP

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_base_5fservice_2eproto__INCLUDED
